---
phase: 01-generic-midi-router
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - rp2040/rp2040.ino
  - rp2040/serial_midi_handler.cpp
  - rp2040/midi_router.h
  - rp2040/midi_router.cpp
autonomous: false

must_haves:
  truths:
    - "Every MIDI handler in rp2040.ino calls routeMidiMessage() instead of containing duplicated filter/forward/LED logic"
    - "Every MIDI handler in serial_midi_handler.cpp calls routeMidiMessage() instead of containing duplicated filter/forward/LED logic"
    - "No duplicated routing logic exists — each handler is a thin wrapper that constructs a MidiMessage and calls routeMidiMessage()"
    - "MIDI messages route correctly between all three interfaces with the same filtering behavior as before the refactor"
    - "Routing works bidirectionally between all three interfaces with correct filtering and LED behavior"
    - "Firmware compiles successfully with arduino-cli"
  artifacts:
    - path: "rp2040/rp2040.ino"
      provides: "Simplified USB Host and USB Device handlers calling routeMidiMessage()"
      contains: "routeMidiMessage"
    - path: "rp2040/serial_midi_handler.cpp"
      provides: "Simplified Serial MIDI handlers calling routeMidiMessage()"
      contains: "routeMidiMessage"
  key_links:
    - from: "rp2040/rp2040.ino"
      to: "rp2040/midi_router.h"
      via: "#include and routeMidiMessage() calls in every handler"
      pattern: '#include "midi_router.h"'
    - from: "rp2040/serial_midi_handler.cpp"
      to: "rp2040/midi_router.h"
      via: "#include and routeMidiMessage() calls in every handler"
      pattern: '#include "midi_router.h"'
---

<objective>
Rewire all 33+ MIDI message handlers in rp2040.ino and serial_midi_handler.cpp to call `routeMidiMessage()` from the midi_router module created in Plan 01, then verify compilation.

Purpose: This completes ARCH-01 by eliminating all duplicated routing logic. Each handler becomes a 3-5 line function that constructs a MidiMessage struct and calls routeMidiMessage(). The codebase goes from ~530 lines of duplicated handlers to ~33 thin wrappers + one ~100-line router function.

Output: Refactored `rp2040.ino` and `serial_midi_handler.cpp` with dramatically reduced handler code, verified to compile.
</objective>

<execution_context>
@/home/han/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/han/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-generic-midi-router/01-01-SUMMARY.md
@rp2040/rp2040.ino
@rp2040/serial_midi_handler.cpp
@rp2040/serial_midi_handler.h
@rp2040/midi_router.h
@rp2040/midi_router.cpp
@rp2040/usb_host_wrapper.h
@rp2040/midi_filters.h
@rp2040/midi_instances.h
@rp2040/led_utils.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewire all handlers in rp2040.ino and serial_midi_handler.cpp</name>
  <files>rp2040/rp2040.ino, rp2040/serial_midi_handler.cpp, rp2040/midi_router.h, rp2040/midi_router.cpp</files>
  <action>
  **In `rp2040/rp2040.ino`:**

  1. Add `#include "midi_router.h"` near the top with other includes.

  2. Make `isConnectedToComputer` volatile: change `bool isConnectedToComputer = false;` to `volatile bool isConnectedToComputer = false;`

  3. Replace EVERY USB Host handler body (lines 284-569) with a thin wrapper that constructs a MidiMessage and calls routeMidiMessage(). Example pattern for a channel message:

  ```cpp
  void usbh_onNoteOn(byte channel, byte note, byte velocity) {
      MidiMessage msg = {};
      msg.type = MIDI_MSG_NOTE;
      msg.channel = channel;
      msg.data1 = note;
      msg.data2 = velocity;
      routeMidiMessage(MIDI_INTERFACE_USB_HOST, msg);
  }
  ```

  For NoteOff, use the SAME pattern (msg.type = MIDI_MSG_NOTE). The routeMidiMessage function needs to distinguish NoteOn from NoteOff for forwarding. To handle this, add a `bool isNoteOff` field to MidiMessage in midi_router.h, OR better: use `velocity == 0` convention (Note On with velocity 0 = Note Off), OR add a `byte statusByte` field. The CLEANEST approach: add an `enum MidiSubType { MIDI_SUB_NOTE_ON, MIDI_SUB_NOTE_OFF }` or simply add a `bool isNoteOn` field. 
  
  RECOMMENDED: Add a `byte subType` field to MidiMessage (0 = default/NoteOn, 1 = NoteOff) and update midi_router.h. This is needed because NoteOn and NoteOff share the same filter (MIDI_MSG_NOTE) but require different send functions:
  - NoteOn: `sendNoteOn()`, `USB_D.sendNoteOn()`, `sendSerialMidiNoteOn()`
  - NoteOff: `sendNoteOff()`, `USB_D.sendNoteOff()`, `sendSerialMidiNoteOff()`

  **Update midi_router.h** to add `byte subType;` to MidiMessage struct (value 0 = on/default, 1 = off/alternate). Then update midi_router.cpp's forwardToInterface to check `msg.subType` for MIDI_MSG_NOTE to decide between sendNoteOn/sendNoteOff.

  Apply this to all USB Host handlers (11 functions):
  - `usbh_onNoteOn` → type=NOTE, subType=0
  - `usbh_onNoteOff` → type=NOTE, subType=1
  - `usbh_onPolyAftertouch` → type=POLY_AFTERTOUCH
  - `usbh_onControlChange` → type=CONTROL_CHANGE
  - `usbh_onProgramChange` → type=PROGRAM_CHANGE
  - `usbh_onAftertouchHandle` → type=CHANNEL_AFTERTOUCH
  - `usbh_onPitchBend` → type=PITCH_BEND, use msg.pitchBend
  - `usbh_onSysEx` → type=SYSEX, msg.sysexData=array, msg.sysexSize=size, msg.channel=0
  - `usbh_onMidiClock` → type=REALTIME, msg.rtType=midi::Clock, msg.channel=0
  - `usbh_onMidiStart` → type=REALTIME, msg.rtType=midi::Start, msg.channel=0
  - `usbh_onMidiContinue` → type=REALTIME, msg.rtType=midi::Continue, msg.channel=0
  - `usbh_onMidiStop` → type=REALTIME, msg.rtType=midi::Stop, msg.channel=0

  4. Replace EVERY USB Device handler body (lines 575-810) similarly. Source = MIDI_INTERFACE_USB_DEVICE. Same pattern.

  Note the existing bug in `usbd_onControlChange` (line 621): it's MISSING the channel filter check. By routing through routeMidiMessage(), this bug is automatically FIXED because routeMidiMessage() always checks channel filter for channel messages. Document this bug fix.

  Apply to all USB Device handlers (11 functions):
  - `usbd_onNoteOn` → type=NOTE, subType=0
  - `usbd_onNoteOff` → type=NOTE, subType=1
  - `usbd_onControlChange` → type=CONTROL_CHANGE (now gets channel filter!)
  - `usbd_onProgramChange` → type=PROGRAM_CHANGE
  - `usbd_onAftertouch` → type=CHANNEL_AFTERTOUCH
  - `usbd_onPitchBend` → type=PITCH_BEND
  - `usbd_onSysEx` → type=SYSEX
  - `usbd_onClock` → type=REALTIME, rtType=midi::Clock
  - `usbd_onStart` → type=REALTIME, rtType=midi::Start
  - `usbd_onContinue` → type=REALTIME, rtType=midi::Continue
  - `usbd_onStop` → type=REALTIME, rtType=midi::Stop

  **In `serial_midi_handler.cpp`:**

  1. Add `#include "midi_router.h"` at the top.

  2. Replace EVERY local handler body (lines 119-351) with thin wrappers. Source = MIDI_INTERFACE_SERIAL.

  Apply to all Serial handlers (11 functions):
  - `serial_onNoteOn` → type=NOTE, subType=0
  - `serial_onNoteOff` → type=NOTE, subType=1
  - `serial_onControlChange` → type=CONTROL_CHANGE
  - `serial_onProgramChange` → type=PROGRAM_CHANGE
  - `serial_onAftertouch` → type=CHANNEL_AFTERTOUCH
  - `serial_onPitchBend` → type=PITCH_BEND
  - `serial_onSysEx` → type=SYSEX
  - `serial_onClock` → type=REALTIME, rtType=midi::Clock
  - `serial_onStart` → type=REALTIME, rtType=midi::Start
  - `serial_onContinue` → type=REALTIME, rtType=midi::Continue
  - `serial_onStop` → type=REALTIME, rtType=midi::Stop

  3. Remove the `extern bool isConnectedToComputer;` line from serial_midi_handler.cpp since the router now handles the isConnectedToComputer check.

  4. Keep all the `sendSerialMidi*()` functions (lines 79-113) — these are still needed by midi_router.cpp to forward TO serial.

  5. Keep `setupSerialMidi()` and `loopSerialMidi()` unchanged.

  **CRITICAL behavioral preservation:**
  - USB Host handlers use `triggerUsbLED()` — router handles this via source type
  - Serial handlers use `triggerSerialLED()` — router handles this via source type
  - USB Device handlers use `triggerUsbLED()` — router handles this via source type
  - `usbd_onClock()` does NOT trigger LED (commented out) — router must handle this exception
  - MIDI Clock messages suppress debug logging (too frequent) — router must handle this

  **C-style wrappers (lines 63-74)** — keep these as-is. They call `usbh_on*Handle()` which now call routeMidiMessage().

  **After all rewrites, the handler section of rp2040.ino should shrink from ~530 lines to ~150 lines.**
  </action>
  <verify>
  - `grep -c "routeMidiMessage" rp2040/rp2040.ino` shows 22+ calls (11 USB Host + 11 USB Device handlers)
  - `grep -c "routeMidiMessage" rp2040/serial_midi_handler.cpp` shows 11 calls (11 Serial handlers)
  - `grep -c "isMidiFiltered" rp2040/rp2040.ino` shows 0 (all filter logic moved to router)
  - `grep -c "isMidiFiltered" rp2040/serial_midi_handler.cpp` shows 0 (all filter logic moved to router)
  - Each handler function body is 3-7 lines (construct MidiMessage + call routeMidiMessage)
  - `wc -l rp2040/rp2040.ino` is significantly smaller than 811
  </verify>
  <done>All 33 MIDI handlers are thin wrappers calling routeMidiMessage(), no duplicated routing logic remains, and the USB Device CC channel filter bug is fixed as a side effect</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Checkpoint: Verify routing across all three interfaces</name>
  <action>Exercise routing from each source to the other two interfaces and confirm filtering and LED behavior.</action>
  <what-built>Unified routing via routeMidiMessage() for USB Host, USB Device, and Serial handlers</what-built>
  <how-to-verify>
    1. Flash the firmware built in Task 2 to the RP2040.
    2. Set a known filter configuration (e.g., disable a specific channel and disable one message type per interface) so filter effects are observable.
    3. USB Host source: send Note On/Off, CC, and Clock from a USB MIDI controller into the USB Host port.
       - Expect forwarding to USB Device and Serial (except any filtered channel/type).
       - USB LED should trigger on non-Clock messages; Clock should not spam LEDs.
    4. USB Device source: send the same message types from the host computer into the USB Device interface.
       - Expect forwarding to USB Host and Serial (except any filtered channel/type).
       - USB LED should trigger on non-Clock messages; Clock should NOT trigger LED (matches existing behavior).
    5. Serial source: send Note On/Off, CC, and Clock over Serial MIDI.
       - Expect forwarding to USB Host and USB Device (except any filtered channel/type).
       - Serial LED should trigger on non-Clock messages.
    6. For each source, confirm the filtered channel/type does NOT forward, and unfiltered messages forward to both destinations.
  </how-to-verify>
  <resume-signal>Type "approved" if routing, filtering, and LEDs behave correctly across all three interfaces, or describe issues.</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Verify firmware compiles with arduino-cli</name>
  <files>rp2040/rp2040.ino</files>
  <action>
  Attempt to compile the firmware using the Arduino CLI command from the project's build system:

  ```bash
  ./arduino-cli compile --fqbn rp2040:rp2040:rpipico:usbstack=tinyusb -v ./rp2040
  ```

  If `./arduino-cli` is not available (the committed binary may have been removed), try:
  - `arduino-cli compile --fqbn rp2040:rp2040:rpipico:usbstack=tinyusb -v ./rp2040`
  - Or locate the arduino-cli binary: `which arduino-cli` or `find / -name arduino-cli -type f 2>/dev/null`

  If arduino-cli is genuinely unavailable:
  - Document that compilation verification is deferred to the user
  - Manually verify: review all #include chains, function signatures match between declarations and calls, extern declarations match definitions
  - Check for common issues:
    - `midi_router.h` included in all files that call routeMidiMessage()
    - MidiMessage struct fields match what handlers populate
    - volatile on isConnectedToComputer matches extern declarations
    - No circular includes between midi_router.h and other headers

  If compilation fails, fix the errors. Common issues to watch for:
  - Missing includes
  - Type mismatches (byte vs uint8_t — these are the same on Arduino)
  - Missing extern declarations
  - Forgotten volatile qualifiers on extern declarations
  - midi::MidiType vs raw byte for realtime messages
  </action>
  <verify>
  - Arduino CLI compile command exits with 0 (success), OR
  - If arduino-cli unavailable: manual code review confirms no type errors, missing includes, or signature mismatches
  </verify>
  <done>Firmware compiles successfully with no errors, confirming all handler rewiring is correct and the midi_router module integrates properly with the existing codebase</done>
</task>

</tasks>

<verification>
- All 33+ handlers in rp2040.ino and serial_midi_handler.cpp are thin wrappers calling routeMidiMessage()
- Zero instances of duplicated filter→forward→LED logic remain in handler functions
- `grep -c "isMidiFiltered" rp2040/rp2040.ino rp2040/serial_midi_handler.cpp` returns 0 for both files
- `grep -c "routeMidiMessage" rp2040/rp2040.ino rp2040/serial_midi_handler.cpp` returns 22+ and 11 respectively
- Firmware compiles with arduino-cli (or manual review if CLI unavailable)
- USB Device CC handler now has channel filtering (bug fix BUGF-01 side effect)
- Hardware verification confirms routing between all three interfaces with expected filtering and LED behavior
</verification>

<success_criteria>
1. Every MIDI handler function body is 3-7 lines (construct MidiMessage + call routeMidiMessage)
2. No handler contains isMidiFiltered(), isChannelEnabled(), or direct send calls to other interfaces
3. rp2040.ino is significantly smaller (target: ~280 lines, down from 811)
4. serial_midi_handler.cpp handler section is significantly smaller
5. Firmware compiles successfully
6. isConnectedToComputer is marked volatile
7. Routing is verified from each source (USB Host, USB Device, Serial) to the other two interfaces with correct filtering and LED behavior
</success_criteria>

<output>
After completion, create `.planning/phases/01-generic-midi-router/01-02-SUMMARY.md`
</output>
