---
phase: 01-generic-midi-router
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rp2040/midi_router.h
  - rp2040/midi_router.cpp
  - rp2040/usb_host_wrapper.h
  - rp2040/usb_host_wrapper.cpp
autonomous: true

must_haves:
  truths:
    - "A single routeMidiMessage() function exists that handles channel filtering, source filtering, forwarding to other interfaces, and LED triggering"
    - "Cross-core shared variables (midi_host_mounted, midi_dev_addr, isConnectedToComputer) are marked volatile"
    - "Cross-core access to multi-byte shared state uses RP2040 spinlock synchronization"
  artifacts:
    - path: "rp2040/midi_router.h"
      provides: "MidiMessage struct, MidiSource enum, routeMidiMessage() declaration"
      contains: "routeMidiMessage"
    - path: "rp2040/midi_router.cpp"
      provides: "Generic routing implementation: filter check, forward to 2 other interfaces, LED trigger"
      contains: "routeMidiMessage"
    - path: "rp2040/usb_host_wrapper.cpp"
      provides: "volatile qualifiers on midi_dev_addr and midi_host_mounted"
      contains: "volatile"
  key_links:
    - from: "rp2040/midi_router.cpp"
      to: "rp2040/midi_filters.h"
      via: "isMidiFiltered() and isChannelEnabled() calls"
      pattern: "isMidiFiltered|isChannelEnabled"
    - from: "rp2040/midi_router.cpp"
      to: "rp2040/usb_host_wrapper.h"
      via: "sendNoteOn/sendControlChange/etc for USB Host forwarding"
      pattern: "sendNoteOn|sendControlChange|sendRealTime"
    - from: "rp2040/midi_router.cpp"
      to: "rp2040/serial_midi_handler.h"
      via: "sendSerialMidiNoteOn/etc for Serial MIDI forwarding"
      pattern: "sendSerialMidi"
    - from: "rp2040/midi_router.cpp"
      to: "rp2040/midi_instances.h"
      via: "USB_D.send* for USB Device forwarding"
      pattern: "USB_D"
---

<objective>
Create the generic MIDI router module (`midi_router.h/.cpp`) containing a single `routeMidiMessage()` function, and add cross-core safety to shared variables.

Purpose: This is the foundation that Plan 02 will wire all existing handlers into. The router function replaces the duplicated filter→forward→LED pattern found 33+ times across the codebase. Cross-core safety (ARCH-06) is addressed here because the router function is called from both cores and accesses shared state.

Output: New `midi_router.h/.cpp` module, `volatile` qualifiers added to cross-core variables in `usb_host_wrapper.cpp`.
</objective>

<execution_context>
@/home/han/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/han/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@rp2040/rp2040.ino
@rp2040/midi_filters.h
@rp2040/midi_filters.cpp
@rp2040/usb_host_wrapper.h
@rp2040/usb_host_wrapper.cpp
@rp2040/serial_midi_handler.h
@rp2040/serial_midi_handler.cpp
@rp2040/midi_instances.h
@rp2040/led_utils.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cross-core safety to shared variables (ARCH-06)</name>
  <files>rp2040/usb_host_wrapper.h, rp2040/usb_host_wrapper.cpp</files>
  <action>
  Add `volatile` qualifier to the three cross-core shared variables:

  In `usb_host_wrapper.cpp`:
  - Change `uint8_t midi_dev_addr = 0;` to `volatile uint8_t midi_dev_addr = 0;`
  - Change `bool midi_host_mounted = false;` to `volatile bool midi_host_mounted = false;`

  In `usb_host_wrapper.h`:
  - Change `extern uint8_t midi_dev_addr;` to `extern volatile uint8_t midi_dev_addr;`
  - Change `extern bool midi_host_mounted;` to `extern volatile bool midi_host_mounted;`

  In `rp2040.ino` (will be done by Plan 02, but note):
  - `isConnectedToComputer` is only written during `setup()` before Core 1 starts, so it is effectively read-only during runtime. Still mark it `volatile` for correctness since Core 1 could theoretically read it.

  For synchronization: `midi_host_mounted` (bool) and `midi_dev_addr` (uint8_t) are both single-byte writes on ARM Cortex-M0+ which are atomic. The `volatile` qualifier is sufficient — no spinlock needed for these since they are written atomically by Core 1 in `tuh_midi_mount_cb`/`tuh_midi_umount_cb` and read by Core 0. However, the *pair* of `midi_dev_addr` + `midi_host_mounted` could be read in an inconsistent state (addr updated but mounted not yet, or vice versa). To handle this safely:

  - Add `#include "pico/sync.h"` to `usb_host_wrapper.cpp`
  - Create a static spinlock: `static auto_init_mutex(midi_host_mutex);`
  - Wrap the writes to `midi_dev_addr` + `midi_host_mounted` in `tuh_midi_mount_cb` and `tuh_midi_umount_cb` with `mutex_enter_blocking(&midi_host_mutex)` / `mutex_exit(&midi_host_mutex)`
  - Add a public accessor function `bool getMidiHostState(uint8_t *addr)` that reads both under the mutex and returns `midi_host_mounted` while writing `midi_dev_addr` to `*addr`
  - Export `getMidiHostState()` in `usb_host_wrapper.h`

  NOTE: Use mutex (not spinlock) because the critical section is short and mutex is the standard RP2040 SDK cross-core synchronization primitive. Do NOT use `critical_section_t` — that disables interrupts which could affect USB Host timing on Core 1.
  </action>
  <verify>
  - `grep -n "volatile" rp2040/usb_host_wrapper.cpp rp2040/usb_host_wrapper.h` shows volatile on midi_dev_addr and midi_host_mounted
  - `grep -n "mutex" rp2040/usb_host_wrapper.cpp` shows mutex usage around mount/unmount state changes
  - `grep -n "getMidiHostState" rp2040/usb_host_wrapper.h` shows the new accessor function
  </verify>
  <done>Cross-core shared variables are volatile, multi-variable state changes are mutex-protected, and a safe accessor function exists for reading host state from Core 0</done>
</task>

<task type="auto">
  <name>Task 2: Create midi_router module with routeMidiMessage()</name>
  <files>rp2040/midi_router.h, rp2040/midi_router.cpp</files>
  <action>
  Create the generic MIDI routing module that consolidates the duplicated handler pattern.

  **`rp2040/midi_router.h`:**

  ```cpp
  #ifndef MIDI_ROUTER_H
  #define MIDI_ROUTER_H

  #include <Arduino.h>
  #include "midi_filters.h"

  // Source interface that received the MIDI message
  // (reuses MidiInterfaceType values but semantically means "where it came from")
  typedef MidiInterfaceType MidiSource;

  // Union-style struct to hold any MIDI message data
  typedef struct {
      MidiMsgType type;       // Message type (NOTE, CC, etc.)
      byte channel;           // MIDI channel 1-16 (0 for system messages)
      byte data1;             // Note number, CC number, program number, etc.
      byte data2;             // Velocity, CC value, aftertouch amount, etc.
      int pitchBend;          // Pitch bend value (only for PITCH_BEND type)
      byte *sysexData;        // Pointer to SysEx data (only for SYSEX type)
      unsigned sysexSize;     // SysEx data size (only for SYSEX type)
      midi::MidiType rtType;  // Real-time message subtype (Clock, Start, Continue, Stop)
  } MidiMessage;

  // Route a MIDI message from source to all other interfaces, applying filters
  void routeMidiMessage(MidiSource source, const MidiMessage &msg);

  #endif // MIDI_ROUTER_H
  ```

  **`rp2040/midi_router.cpp`:**

  Implement `routeMidiMessage()` following the EXACT pattern from the existing handlers:

  1. **Channel filter** (if message has a channel, i.e., type != SYSEX && type != REALTIME):
     - `if (msg.channel != 0 && !isChannelEnabled(msg.channel)) return;`

  2. **Source filter** — check if this message type is blocked for the source interface:
     - `if (isMidiFiltered(source, msg.type)) return;`

  3. **Forward to each of the OTHER TWO interfaces** (skip source):
     For each destination interface (USB_HOST, USB_DEVICE, SERIAL) that is NOT the source:
     - Check `isMidiFiltered(dest, msg.type)` — skip if filtered
     - For USB_DEVICE: also check `isConnectedToComputer` before sending
     - For USB_HOST: use `sendNoteOn()`/`sendControlChange()`/etc. from `usb_host_wrapper.h`
     - For USB_DEVICE: use `USB_D.sendNoteOn()`/etc. from `midi_instances.h`
     - For SERIAL: use `sendSerialMidiNoteOn()`/etc. from `serial_midi_handler.h`

  4. **Trigger LED**:
     - If source is USB_HOST or USB_DEVICE: call `triggerUsbLED()`
     - If source is SERIAL: call `triggerSerialLED()`
     - Exception: for REALTIME Clock from USB_DEVICE, do NOT trigger LED (matching existing behavior where `usbd_onClock()` has `triggerUsbLED()` commented out)

  Use a helper function `static void forwardToInterface(MidiInterfaceType dest, const MidiMessage &msg)` to avoid repeating the send logic. Inside this function, use a switch on `msg.type` to call the correct send function for each message type on each interface.

  For USB_HOST sends, the function signatures are (from usb_host_wrapper.h):
  - `sendNoteOn(channel, note, velocity)` — returns bool
  - `sendNoteOff(channel, note, velocity)`
  - `sendControlChange(channel, controller, value)`
  - `sendProgramChange(channel, program)`
  - `sendAfterTouch(channel, pressure)` — Channel AT
  - `sendPolyAfterTouch(channel, note, pressure)`
  - `sendPitchBend(channel, bend)`
  - `sendSysEx(size, array)`
  - `sendRealTime(rtByte)` — takes raw byte like 0xF8

  For USB_DEVICE sends (via USB_D object from midi_instances.h):
  - `USB_D.sendNoteOn(note, velocity, channel)` — note different param order!
  - `USB_D.sendNoteOff(note, velocity, channel)`
  - `USB_D.sendControlChange(controller, value, channel)`
  - `USB_D.sendProgramChange(program, channel)`
  - `USB_D.sendAfterTouch(note, amount, channel)` — Poly AT (3 params)
  - `USB_D.sendAfterTouch(pressure, channel)` — Channel AT (2 params)
  - `USB_D.sendPitchBend(bend, channel)`
  - `USB_D.sendSysEx(size, array)`
  - `USB_D.sendRealTime(midi::Clock)` etc.

  For SERIAL sends (from serial_midi_handler.h):
  - `sendSerialMidiNoteOn(channel, note, velocity)`
  - `sendSerialMidiNoteOff(channel, note, velocity)`
  - `sendSerialMidiControlChange(channel, controller, value)`
  - `sendSerialMidiProgramChange(channel, program)`
  - `sendSerialMidiAfterTouch(channel, note, amount)` — Poly AT
  - `sendSerialMidiAfterTouchChannel(channel, pressure)` — Channel AT
  - `sendSerialMidiPitchBend(channel, bend)`
  - `sendSerialMidiSysEx(size, array)`
  - `sendSerialMidiRealTime(midi::MidiType)`

  For REALTIME messages forwarded to USB Host, convert `msg.rtType` to raw byte:
  - `midi::Clock` → `0xF8`, `midi::Start` → `0xFA`, `midi::Continue` → `0xFB`, `midi::Stop` → `0xFC`

  Include these headers in midi_router.cpp:
  - `"midi_router.h"`
  - `"midi_filters.h"`
  - `"usb_host_wrapper.h"`
  - `"serial_midi_handler.h"`
  - `"midi_instances.h"`
  - `"led_utils.h"`
  - `"serial_utils.h"` (for debug logging — keep minimal, only log non-Clock messages)

  Use `extern bool isConnectedToComputer;` (will be made volatile in Plan 02).

  IMPORTANT: The routeMidiMessage function will be called from BOTH cores (Core 1 for USB Host callbacks, Core 0 for USB Device and Serial callbacks). The function itself is safe because:
  - Filter state reads are atomic (single-byte bools)
  - Send functions are interface-specific and don't conflict
  - LED triggers use millis() which is safe across cores
  No additional locking needed inside routeMidiMessage itself.
  </action>
  <verify>
  - File `rp2040/midi_router.h` exists with `MidiMessage` struct and `routeMidiMessage` declaration
  - File `rp2040/midi_router.cpp` exists with `routeMidiMessage` implementation
  - `grep -c "forwardToInterface\|routeMidiMessage" rp2040/midi_router.cpp` shows multiple occurrences
  - `grep "isChannelEnabled\|isMidiFiltered" rp2040/midi_router.cpp` shows filter checks
  - `grep "triggerUsbLED\|triggerSerialLED" rp2040/midi_router.cpp` shows LED triggers
  </verify>
  <done>A complete midi_router module exists with routeMidiMessage() that handles all MIDI message types, applies channel and type filtering, forwards to the other two interfaces with correct send function signatures, and triggers the appropriate LED indicator</done>
</task>

</tasks>

<verification>
- `rp2040/midi_router.h` declares MidiMessage struct and routeMidiMessage()
- `rp2040/midi_router.cpp` implements the complete routing logic
- `rp2040/usb_host_wrapper.h` and `.cpp` have volatile qualifiers on shared variables
- Cross-core mutex protects multi-variable host state changes
- No compilation attempted yet (Plan 02 will integrate and compile)
</verification>

<success_criteria>
1. midi_router.h defines MidiMessage struct with fields for all MIDI message types
2. routeMidiMessage() handles all 8 message types (Note, PolyAT, CC, ProgramChange, ChannelAT, PitchBend, SysEx, Realtime)
3. For each message type, routeMidiMessage() filters by channel, filters by source, then forwards to the other 2 interfaces with per-destination filtering
4. volatile qualifiers applied to midi_host_mounted and midi_dev_addr
5. Mutex protects paired writes to midi_dev_addr + midi_host_mounted in mount/unmount callbacks
</success_criteria>

<output>
After completion, create `.planning/phases/01-generic-midi-router/01-01-SUMMARY.md`
</output>
