---
phase: 03-non-blocking-patterns
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - rp2040/imu_handler.h
  - rp2040/imu_handler.cpp
  - rp2040/web_serial_config.cpp
autonomous: true

must_haves:
  truths:
    - "IMU calibration no longer blocks the main loop and completes asynchronously"
    - "Web Serial CALIBRATE_IMU responds immediately and reports completion when calibration finishes"
    - "MIDI routing continues during IMU calibration"
  artifacts:
    - path: "rp2040/imu_handler.h"
      provides: "Non-blocking IMU calibration API"
      contains: "startIMUCalibration"
    - path: "rp2040/imu_handler.cpp"
      provides: "Calibration state machine driven by millis()"
      contains: "updateIMUCalibration"
    - path: "rp2040/web_serial_config.cpp"
      provides: "Async CALIBRATE_IMU command handling"
      contains: "CALIBRATE_IMU"
  key_links:
    - from: "rp2040/web_serial_config.cpp"
      to: "rp2040/imu_handler.h"
      via: "CALIBRATE_IMU triggers startIMUCalibration"
      pattern: "CALIBRATE_IMU"
    - from: "rp2040/imu_handler.cpp"
      to: "rp2040/imu_handler.h"
      via: "loopIMU calls updateIMUCalibration"
      pattern: "updateIMUCalibration"
---

<objective>
Convert IMU calibration into a non-blocking state machine so the main loop continues routing MIDI while calibration is in progress.

Purpose: Satisfies PERF-02 by removing the 4-second blocking calibration from Core 0 and ensuring Web Serial remains responsive.

Output: IMU handler exposes async calibration entry points; web serial triggers start and reports completion.
</objective>

<execution_context>
@/home/han/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/han/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-non-blocking-patterns/03-RESEARCH.md
@rp2040/imu_handler.h
@rp2040/imu_handler.cpp
@rp2040/web_serial_config.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Introduce a non-blocking IMU calibration state machine</name>
  <files>rp2040/imu_handler.h, rp2040/imu_handler.cpp</files>
  <action>
  Replace the blocking `calibrateIMU()` with an async state machine and helper APIs:

  - In `rp2040/imu_handler.h`, add new functions (keep names ASCII and consistent with existing style):
    - `void startIMUCalibration();`
    - `void updateIMUCalibration();`
    - `bool isIMUCalibrationActive();`
  - In `rp2040/imu_handler.cpp`, add a static calibration state struct with fields:
    - `bool active`
    - `uint32_t startTime`
    - `uint32_t nextSampleAt`
    - `uint16_t sampleCount`
    - `float gyroXsum/gyroYsum/gyroZsum`
    - `float accelXsum/accelYsum/accelZsum`
  - Convert calibration flow to time-sliced steps:
    1. `startIMUCalibration()` initializes state, sets `active=true`, and records `startTime = millis()`.
    2. `updateIMUCalibration()` runs in `loopIMU()` (or from `loop()`) and:
       - Waits 3000ms for settle (no delay; just check `millis() - startTime`)
       - Collects one sample every 10ms (or equivalent) until `calibrationSamples` reached
       - Computes offsets and sets `calibrated=true` when done; sets `active=false`
    3. Ensure `calibrateIMU()` either becomes a thin wrapper that calls `startIMUCalibration()` or is removed from call sites; do not leave any `delay()` in this file.
  - Ensure sampling still uses the same IMU API calls (`IMU.update()`, `IMU.getAccel()`, `IMU.getGyro()`) and the same math as the previous loop.
  - While calibration is active, `loopIMU()` should continue running but avoid emitting MIDI CC output until `calibrated` is true (maintain current behavior if it already gates on `calibrated`).
  </action>
  <verify>
  - `grep -n "delay(.*)" rp2040/imu_handler.cpp` returns no matches
  - `updateIMUCalibration()` exists and is called regularly (from `loopIMU()` or main loop)
  - Calibration still computes offsets using 100 samples and subtracts 1g from accel Z
  </verify>
  <done>IMU calibration advances incrementally without blocking, and calibration offsets are computed once sampling completes</done>
</task>

<task type="auto">
  <name>Task 2: Update CALIBRATE_IMU command to async start + completion report</name>
  <files>rp2040/web_serial_config.cpp</files>
  <action>
  Make the CALIBRATE_IMU command non-blocking and report completion when the state machine finishes:

  - Replace the direct `calibrateIMU()` call with `startIMUCalibration()`.
  - Immediately return a JSON status indicating calibration started (keep existing message structure if possible).
  - Add a lightweight completion notification in `processWebSerialConfig()` or an adjacent helper:
    - Track previous calibration active state in a static flag
    - When `isIMUCalibrationActive()` transitions from true â†’ false, emit a JSON success message: `{"status":"Success","command":"CALIBRATE_IMU","message":"IMU calibration complete"}`
  - Ensure this completion message is sent once per calibration run (no repeats).
  - Do not block or delay in the command handler.
  </action>
  <verify>
  - CALIBRATE_IMU returns immediately without blocking
  - A completion JSON message is emitted after calibration finishes
  </verify>
  <done>Web Serial CALIBRATE_IMU starts calibration asynchronously and reports completion when the state machine finishes</done>
</task>

</tasks>

<verification>
- No delay() calls remain in `rp2040/imu_handler.cpp`
- CALIBRATE_IMU command returns immediately and a completion message is produced later
- During calibration, main loop continues processing MIDI (no blocking waits)
</verification>

<success_criteria>
1. IMU calibration completes asynchronously with the same sampling logic as before
2. CALIBRATE_IMU no longer blocks Web Serial processing
3. MIDI routing is uninterrupted during calibration
</success_criteria>

<output>
After completion, create `.planning/phases/03-non-blocking-patterns/03-02-SUMMARY.md`
</output>
